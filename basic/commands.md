# 指令格式基础

就如物理公式那样，$P=\frac{W}{t}$。如果我们要求功率 $P$，那么就要将 $W$、$t$ 的值代入该公式。指令也是这样。如果我们要完成指定的目的，就要把指定的值代入到指定的位置。接下来，我们来学习**指令格式**（command pattern），这也是 OP 所要掌握的基础知识。在后文中，均会采用在本文中所使用的格式进行叙述。

## 指令的基本构成

Minecraft 中，指令以 `/` 开头。例如 `/help`、`/tp`、`/kill` 等，均为指令。紧跟在 `/` 后面的单词，例如 `help`、`tp`、`kill`，叫做**指令头**（command header）或者更通俗地叫做**指令名**（command name）。

上面的三个指令，有什么不同点？

如果你单独地在服务器内执行一个 `/help`，那么得到的结果是「显示帮助信息」。这种情况下，我们称作「该指令执行成功」。那么如果我们也像这样，单独地执行 `/tp` 而不加任何其它的内容上去呢？相信你一定很快能明白。`/tp` 指令的后面必须接上一个玩家名才能够正确执行。

在这里，我们把 `/tp` 指令后面那个必须接上的玩家名叫做**参数**（**argument** / parameter)。熟悉 `/tp` 指令的 OP 都应该知道，`/tp` 实际上后面可以跟两个玩家名。跟一个玩家名的时候，代表把自己传送到指定玩家的位置；跟两个玩家名的时候，代表把第一个玩家传送到第二个玩家的位置。

像这样，如果加一个参数，指令成功了；如果加两个参数，指令也成功了，那么我们就称第二个参数是**可选的**（optional）；如果不加任何参数，指令失败，那么我们就称必填的那个参数是**必选的**（required）。

!> **判断一个指令的成功与否，并不在于其是否实现了操作者的目的。**一个指令的成功与否应该取决于它执行后所输出的信息，如果没有任何报错，那么代表执行成功。

`/kill` 指令也一样，当它不带任何参数的时候，代表杀死自己（的游戏角色）；当它带了一个参数的时候，代表杀死指定玩家（的游戏角色）。因此它的第一个参数就是**可选的**。

那么，这些关系该如何表达呢？

一般地，我们把必选参数用 `<>` 括起来，例如 `<我是一个必选参数>`；把可选参数用 `[]` 括起来或者打上 `?`，例如 `[我是一个可选参数]` 或者 `<我是一个可选参数?>`。

上述的三个指令的结构就可以这样表示：

```minecraft
/help
/tp <玩家 A> <玩家 B?>
/kill <玩家?>
```

接下来我们来做几个练习题：

1. **下列表示<u>可选参数</u>的是**

    A. `<arg>`
    B. `<arg?>`
    C. `[arg?]`
    D. `arg?`

2. **下列指令中，必须带一个参数的是**

    A. `/op <玩家名>`
    B. `/tp <玩家名> <玩家名?>`
    C. `/kill [玩家名]`
    D. `/stop`

3. **下列指令中，能够执行成功的有**

    A. `/fly`
    B. `/gamemode`
    C. `/back`
    D. `/login`

<div class="reverse"><strong>答案:</strong> B A AC</div>
<style>
.reverse {
    transform: rotate(180deg);
    -ms-transform:rotate(180deg);
    -moz-transform:rotate(180deg);
    -webkit-transform:rotate(180deg);
    -o-transform:rotate(180deg);
    filter: progid:DXImageTransform.Microsoft.BasicImage(rotation=1);
}
</style>

根据如上概念，我们可以得出：**指令是由指令头和参数两部分组成的。**其中，指令头永久不变，象征着这个指令的名称和其操作的目的。例如 `/tp` 指令中的 `tp` 指的是 Teleport（传送）；`/stop` 指令中的 `stop` 指的是 Stop（关服）等。参数部分决定了该指令的最终执行结果。

## 参数详解

除了在上文中列举出的「可选参数」和「必选参数」以外，还有许多类型的参数。如果我们要一一地对它们进行分类，是可以的，但是并没有那个必要。接下来我们会详细介绍参数，以及再介绍几个可以帮助理解的参数类型。

!> 如果没有特殊需求，第一节的内容已经足够理解。该解内容属于纵深型内容，因此如果你没有做好准备进行钻研，不建议提前阅读。本节内容不影响具体实践。

### 参数位

为了更方便地表示每一个参数所在的位置，我们确定了**参数位**（**argpos**, argument position）这个概念。一般来讲，如果一个指令是这样的

```minecraft
/comma arg1 arg2 arg3 ...
```

那么，我们将第一个参数位定义为**该指令完整表达中，除去指令头的第一个参数的位置**。上述指令中的第一个参数位就是 `arg1`，第二个参数位就是 `arg2`，以此类推。指令头不能算作参数位，但是我们仍然可以给予其一个定义。       **指令头所在的参数位为 0 **。

一个可选参数也占一个参数位，但是这个参数位可有可无，我们将其称为**不定参数位**（indefinite argpos），将这样的参数叫做**不定参数**（indefinite argument）。该种情况较为复杂，我们将其归类为**派生参数位**的范畴。

表达参数位，我们通常使用 $\mathbb{comma}[]$ 符号中间加上数字。例如表达上例中 `arg2` 的位置这样表示：$\mathbb{comma}[2]$，其中 $\mathbb{comma}$ 是指令名。

### 派生参数位

假设一个指令是这样的

```minecraft
/comma <arg1> [arg2] <arg3> <arg4>
```

那么我们应该如何去解读它呢？这有点令人难以想象。既然 `arg2` 是可选的，为什么它后面还有必选的 `arg3` 和 `arg4` 呢？

实际上，这种表达仍然是正确的，但是需要注意的一点是：**`arg3`、`arg4` 的存在依赖于 `arg2`，如果 `arg2` 不填，那么 `arg3` 和 `arg4` 就不存在**。大概意思就是，`arg3` 和 `arg4` 是依附于 `arg2` 的。

这时对于参数位的计算就有点麻烦了。这种情况下，我们把 `[arg2] <arg3> <arg4>` 解读为同一个参数位，即 `arg1` 处于第一个参数位，`arg2,3,4` 处于第二个参数位。我们把这样，由一个可选参数和零个或多个必选参数所组成的*参数组*所占的参数位称为**派生参数位**（derived argpos）。

### 参数组

在*派生参数位*中我们偶然提到了一个概念：**参数组**（arggroup）。我们可以这样理解，**参数组**将一个指令分成了不同的段落。我们看如下指令：

```minecraft
/comma <arg1> [arg2] <arg3> [arg4] <arg5> <arg6> [arg7]
```

这个时候的理解就特别困难了。根据*派生参数位*的概念，我们可以判断出 `[arg2] <arg3>` 占一个参数位，`[arg4] <arg5>` 占一个参数位，`[arg7]` 独自占一个参数位。我们首先在这里把它们分成三个参数组。在这里我们就需要明确，`<arg3,5,6>` 的依存关系是怎样的呢？

实际上，`arg3` 的存在，前提条件是 `arg2` 被填写；`arg5` 存在，前提条件是 `arg4` 被填写。那么`arg4` 的存在是依赖于 `arg3` 的吗？**如果是，由于 `arg3` 是必选的，随之而来，`arg4` 就失去了它的可选特性，所以是错误的。**这也就证明了上述写法是错误的，因此需要一个概念来弥补之，那就是参数组。

```minecraft
/comma <arg1> ([arg2] <arg3>) ([arg4] <arg5> <arg6>) [arg7]
```

这就是一个标准的参数组写法。对于一个参数组，我们有如下规定：

- 一个参数组内必须包含且只能包含一个可选参数；必须包含一个或一个以上必选参数。
- 每一个参数组占一个参数位，称为派生参数位；参数组内独立从 1 重新划分参数位，称为**子参数位**（child argpos）。例如上面的例子里，位于第二参数位的参数组内，`arg3` 位于**该参数组的**第二参数位，表达为 $\mathbb{comma}[2, 2]$。
- 各个参数组的关系是并列的、可选的；即，既可以单独存在，也可以同时存在，也可以不存在。
- 如果一个参数组是必须存在的，因为某种原因必须将其划分为一个组，那么需要在参数组前加上星号 `*`： `*(<arg> <arg> <...>)` 

随即我们就可以继续得到参数位的基本原则：

- 每一个必选参数和**独立的**可选参数占一个参数位；
- 每一个参数组占一个参数位。

上面的例子里，一共有一个必选参数、两个参数组和一个独立的可选参数，共计占用了 4 个参数位，我们就称这个指令的**长度**（length）为 4。

### 实际参数位

我们创造一个指令来举例子：

```minecraft
/comma <值 A> ([值 B] <值 B1>) [值 C]
```

对于这个指令，在我们实际使用的时候，可能会碰到以下问题：

> 输入的第一个参数对应的参数位是值 A 的没有问题；但是输入的第二个参数则无法判断是对应值 B 还是 C。

在这里，我们就有两种概念。一种是普通参数位，即写在指令结构里的参数位。一种是实际参数位，即我们输入时的参数位。当我们在游戏内输入

```minecraft
/comma hello world
```

的时候，`hello` 为第一个实际参数为，`world` 为第二个实际参数位。当这个指令被执行的时候，`world` 实际上对应值 C。而如果

```minecraft
/comma hello world again
```

这个时候，`world` 对应的是值 B，`again` 对应的是值 C。

在这里我们就可以看出区别：决定一个指令的参数究竟位于哪个参数组的因素是该参数组的长度。当然，你可能回想有没有长度相等的组，实际上是没有的。因为

```minecraft
([值 A] <值 B>) ([值 C] <值 D>)
```

实际上可以转化为

```minecraft
([值 A | 值 C] <值>)
```

在这里，值 A 和值 C 已经处于了一种选择关系，我们下一小节会讲到。至于值 B 和值 D，当对应值 A 时，后面的参数自然对应值 B；当对应值 C 时，后面的参数自然对应值 D。

### 选择参数

**选择参数**（selection）是参数类型的一种，它可以为可选也可以为必选。常常用一个 `|` 号（<kbd>Shift + \\</kbd>）来隔开各个选项。例如 `<a|b|c>` 代表一个必选参数可以为 `a`、`b` 或者 `c` 三种值，且不可以为其它值。

一个简单的例子：

```minecraft
/res <set|pset|...> ...
```

即 `/res set` 指令和 `/res pset` 指令。

联系参数组，我们可以推导出各种转化关系。例如

```minecraft
([值 A] <值 B>) ([值 C] <值 D>) => ([值 A | 值 B] <值>)
```

**对于相同长度的两个参数组，其重合的可选参数转化为选择参数，其余参数值的含义变为不定，根据第一个选择参数的值继续确定，进而还原原有的参数组结构。**大概意思是，两个参数组里，除去第一个可选的参数（值 A 和值 B）以外，其它的必选参数都会失去原有的意义。在新形成的结构里（即一个可选选择参数 + 多个必选参数），这些失去意义的参数将会根据第一个可选选择参数的取值来决定，进而还原它原本的含义。

```minecraft
([值 A | 值 B] <值 C>) ([值 D | 值 E | 值 F] <值 G>) => ([值 A | B | C | D | E | F] <值>)
```

**对于相同长度的两个数组，若其重合的可选参数为选择参数，则将所有的选项合并在同一个可选选择参数中，作为新结构的可选选择参数；将其它的值的含义变为不定，同上述进行操作。**也就是说，如果第一个可选的参数是一个选择参数，那么在新结构中的第一个可选选择参数里的选项就是两个权限组内的第一个可选参数的选项所合并的结果，其余的参数仍然如上面一个例子一样失去意义然后根据第一个选项的值进行转化。

在这个例子里还有一个隐含的对应联系。即如果 $[1]$ 对应 A 或者 B，那么 $[2]$ 对应 C；如果 $[1]$ 对应 D、E 或 F，那么 $[2]$ 对应 G。

## 指令的格式表达例

为了帮助理解，我们在这里列出了几种插件的指令用法，如果你能够读懂，说明你已经理解了。

下文中出现的 `<a|b|c|d|...>` 这种用法叫做**选择参数**（choice），即该参数的位置上的值只能是列出来的那几个。比如 `<a|b|c>` 则代表该参数位置只能填 `a`、`b` 或者 `c`，否则就是错误的。

```minecraft
@Residence
/res <create|set|pset
```

